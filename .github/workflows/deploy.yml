name: CI/CD to AWS Windows Server

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0.x'

      - name: Restore dependencies
        run: dotnet restore MyApp/MyApp.csproj

      - name: Build project
        run: dotnet build MyApp/MyApp.csproj --configuration Release --no-restore

      - name: Publish project
        run: dotnet publish MyApp/MyApp.csproj -c Release -o ./publish

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: app
          path: ./publish

  approval:
    needs: build
    runs-on: windows-latest
    environment:
      name: production
    steps:
      - name: Wait for DevOps Approval
        run: echo "‚è≥ Waiting for DevOps approval before deploying to PRODUCTION"

  deploy:
    needs: approval
    runs-on: windows-latest
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: app
          path: ./app

      - name: Configure WinRM client on runner
        shell: pwsh
        run: |
          Write-Host "üîß CONFIGURING WINRM CLIENT ON GITHUB RUNNER" -ForegroundColor Cyan
          Write-Host "=============================================" -ForegroundColor Cyan
          
          $targetHost = "${{ secrets.AWS_HOST }}"
          
          Write-Host "1. Enabling unencrypted traffic on client..." -ForegroundColor Yellow
          winrm set winrm/config/client '@{AllowUnencrypted="true"}'
          Write-Host "‚úÖ Unencrypted traffic enabled" -ForegroundColor Green
          
          Write-Host "2. Adding target to TrustedHosts..." -ForegroundColor Yellow
          winrm set winrm/config/client '@{TrustedHosts="*"}'
          Write-Host "‚úÖ TrustedHosts configured to accept all hosts" -ForegroundColor Green
          
          Write-Host "3. Enabling Basic authentication..." -ForegroundColor Yellow
          winrm set winrm/config/client/auth '@{Basic="true"}'
          Write-Host "‚úÖ Basic authentication enabled" -ForegroundColor Green
          
          Write-Host "4. Verifying client configuration..." -ForegroundColor Yellow
          winrm get winrm/config/client
          Write-Host "‚úÖ Client configuration complete" -ForegroundColor Green

      - name: Test connectivity with new configuration
        shell: pwsh
        run: |
          Write-Host "üîç TESTING CONNECTIVITY WITH NEW CONFIG" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          
          $hostname = "${{ secrets.AWS_HOST }}"
          $username = "${{ secrets.AWS_USER }}"
          
          Write-Host "Target: $hostname" -ForegroundColor Yellow
          Write-Host "User: $username" -ForegroundColor Yellow
          
          # Create credential
          $securePassword = ConvertTo-SecureString "${{ secrets.AWS_PASSWORD }}" -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)
          
          Write-Host "`n1. Testing WinRM connection..." -ForegroundColor Yellow
          try {
              Test-WSMan -ComputerName $hostname -Port 5985 -UseSSL:$false -Credential $credential -ErrorAction Stop
              Write-Host "‚úÖ WinRM connection successful!" -ForegroundColor Green
          } catch {
              Write-Host "‚ùå WinRM connection failed: $($_.Exception.Message)" -ForegroundColor Red
          }
          
          Write-Host "`n2. Testing PowerShell remoting..." -ForegroundColor Yellow
          try {
              $session = New-PSSession -ComputerName $hostname -Port 5985 -UseSSL:$false -Credential $credential -ErrorAction Stop
              if ($session) {
                  Write-Host "‚úÖ PowerShell remoting successful!" -ForegroundColor Green
                  Remove-PSSession $session
              }
          } catch {
              Write-Host "‚ùå PowerShell remoting failed: $($_.Exception.Message)" -ForegroundColor Red
          }

      - name: Deploy application
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Write-Host "`nüöÄ STARTING DEPLOYMENT" -ForegroundColor Cyan
          WriteHost "====================" -ForegroundColor Cyan
          
          $hostname = "${{ secrets.AWS_HOST }}"
          $username = "${{ secrets.AWS_USER }}"
          
          Write-Host "Target: $hostname" -ForegroundColor Yellow
          Write-Host "User: $username" -ForegroundColor Yellow
          
          # Create credential
          $securePassword = ConvertTo-SecureString "${{ secrets.AWS_PASSWORD }}" -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)
          
          $session = $null
          
          try {
              Write-Host "`nPHASE 1: ESTABLISHING REMOTE SESSION" -ForegroundColor Green
              Write-Host "Creating PowerShell session to $hostname..." -ForegroundColor White
              
              $session = New-PSSession -ComputerName $hostname -Port 5985 -UseSSL:$false -Credential $credential -ErrorAction Stop
              
              if (-not $session) {
                  throw "Failed to create remote session"
              }
              
              Write-Host "‚úÖ Remote session established successfully" -ForegroundColor Green
              
              Write-Host "`nPHASE 2: VERIFYING SERVER ACCESS" -ForegroundColor Green
              $serverInfo = Invoke-Command -Session $session -ScriptBlock {
                  return @{
                      ComputerName = $env:COMPUTERNAME
                      CurrentUser = "$env:USERDOMAIN\$env:USERNAME"
                      IsAdmin = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
                      IISInstalled = (Get-WindowsFeature -Name Web-Server -ErrorAction SilentlyContinue).Installed
                  }
              }
              
              Write-Host "‚úÖ Server access verified:" -ForegroundColor Green
              Write-Host "   - Server: $($serverInfo.ComputerName)" -ForegroundColor White
              Write-Host "   - User: $($serverInfo.CurrentUser)" -ForegroundColor White
              Write-Host "   - Is Admin: $($serverInfo.IsAdmin)" -ForegroundColor White
              Write-Host "   - IIS Installed: $($serverInfo.IISInstalled)" -ForegroundColor White
              
              if (-not $serverInfo.IsAdmin) {
                  Write-Host "‚ö†Ô∏è  Warning: User may not have full administrative privileges" -ForegroundColor Yellow
              }
              
              Write-Host "`nPHASE 3: PREPARING DEPLOYMENT DIRECTORY" -ForegroundColor Green
              $deployPath = "C:\inetpub\wwwroot\myapp"
              
              Invoke-Command -Session $session -ScriptBlock {
                  param($DeployPath)
                  
                  Write-Host "Preparing directory: $DeployPath" -ForegroundColor White
                  
                  # Create backup if directory exists
                  if (Test-Path $DeployPath) {
                      $backupPath = "C:\inetpub\wwwroot\myapp_backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
                      Write-Host "Creating backup: $backupPath" -ForegroundColor White
                      Copy-Item $DeployPath $backupPath -Recurse -Force
                      Write-Host "‚úÖ Backup created" -ForegroundColor Green
                  }
                  
                  # Ensure directory exists and is clean
                  if (-not (Test-Path $DeployPath)) {
                      New-Item -Path $DeployPath -ItemType Directory -Force | Out-Null
                      Write-Host "‚úÖ Directory created" -ForegroundColor Green
                  } else {
                      Remove-Item "$DeployPath\*" -Recurse -Force -ErrorAction SilentlyContinue
                      Write-Host "‚úÖ Directory cleaned" -ForegroundColor Green
                  }
                  
              } -ArgumentList $deployPath
              
              Write-Host "`nPHASE 4: DEPLOYING APPLICATION FILES" -ForegroundColor Green
              $sourceFiles = Get-ChildItem -Path "./app" -Recurse | Measure-Object
              Write-Host "Copying $($sourceFiles.Count) files to server..." -ForegroundColor White
              
              # Display what we're deploying
              Write-Host "Files to deploy:" -ForegroundColor White
              Get-ChildItem -Path "./app" -Recurse | Format-Table Name, Length -AutoSize
              
              Copy-Item -Path "./app/*" -Destination "C:\inetpub\wwwroot\myapp\" -Recurse -Force -ToSession $session
              Write-Host "‚úÖ Files copied successfully" -ForegroundColor Green
              
              Write-Host "`nPHASE 5: VERIFYING DEPLOYMENT" -ForegroundColor Green
              $verification = Invoke-Command -Session $session -ScriptBlock {
                  $deployedFiles = Get-ChildItem -Path "C:\inetpub\wwwroot\myapp" -Recurse | Measure-Object
                  return @{
                      FileCount = $deployedFiles.Count
                      Path = "C:\inetpub\wwwroot\myapp"
                  }
              }
              
              Write-Host "‚úÖ Deployment verified:" -ForegroundColor Green
              Write-Host "   - Files deployed: $($verification.FileCount)" -ForegroundColor White
              Write-Host "   - Location: $($verification.Path)" -ForegroundColor White
              
              Write-Host "`nPHASE 6: RESTARTING IIS" -ForegroundColor Green
              Invoke-Command -Session $session -ScriptBlock {
                  Write-Host "Restarting IIS..." -ForegroundColor White
                  iisreset
                  Write-Host "‚úÖ IIS restarted successfully" -ForegroundColor Green
              }
              
              Write-Host "`nPHASE 7: CLEANUP" -ForegroundColor Green
              Remove-PSSession -Session $session
              Write-Host "Remote session closed" -ForegroundColor White
              
              Write-Host "`nüéâ DEPLOYMENT COMPLETED SUCCESSFULLY!" -ForegroundColor Green
              Write-Host "======================================" -ForegroundColor Green
              Write-Host "üåê Application URL: http://$hostname/myapp" -ForegroundColor Cyan
              Write-Host "‚è∞ Completed: $(Get-Date)" -ForegroundColor White
              
          }
          catch {
              Write-Host "`n‚ùå DEPLOYMENT FAILED!" -ForegroundColor Red
              Write-Host "====================" -ForegroundColor Red
              Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
              
              if ($_.Exception.InnerException) {
                  Write-Host "Inner Error: $($_.Exception.InnerException.Message)" -ForegroundColor Red
              }
              
              # Cleanup session if it exists
              if ($session) {
                  Remove-PSSession -Session $session -ErrorAction SilentlyContinue
                  Write-Host "üßπ Cleaned up remote session" -ForegroundColor White
              }
              
              exit 1
          }

      - name: Final success notification
        if: success()
        shell: pwsh
        run: |
          Write-Host "`nüèÅ DEPLOYMENT SUMMARY" -ForegroundColor Cyan
          Write-Host "===================" -ForegroundColor Cyan
          Write-Host "‚úÖ SUCCESS: Application deployed to production!" -ForegroundColor Green
          Write-Host "üìç URL: http://${{ secrets.AWS_HOST }}/myapp" -ForegroundColor White
          Write-Host "üïí Time: $(Get-Date)" -ForegroundColor White
          Write-Host "üìã Next: Verify application functionality" -ForegroundColor White
