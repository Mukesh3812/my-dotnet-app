name: CI/CD to AWS Windows Server

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0.x'

      - name: Restore dependencies
        run: dotnet restore MyApp/MyApp.csproj

      - name: Build project
        run: dotnet build MyApp/MyApp.csproj --configuration Release --no-restore

      - name: Publish project
        run: dotnet publish MyApp/MyApp.csproj -c Release -o ./publish

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: app
          path: ./publish

  approval:
    needs: build
    runs-on: windows-latest
    environment:
      name: production
    steps:
      - name: Wait for DevOps Approval
        run: echo "‚è≥ Waiting for DevOps approval before deploying to PRODUCTION"

  deploy:
    needs: approval
    runs-on: windows-latest
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: app
          path: ./app

      - name: Test AWS connectivity
        shell: pwsh
        run: |
          Write-Host "üåê Testing connectivity to AWS instance..."
          $hostname = "${{ secrets.AWS_HOST }}"
          
          Write-Host "üîå Testing WinRM HTTP port (5985)..."
          $portTest = Test-NetConnection -ComputerName $hostname -Port 5985 -InformationLevel Quiet
          if ($portTest) {
            Write-Host "‚úÖ Port 5985: OPEN"
          } else {
            Write-Error "‚ùå Port 5985: CLOSED - Check AWS Security Groups"
            Write-Host "üí° Make sure AWS Security Group allows inbound traffic on port 5985"
            exit 1
          }

      - name: Deploy to AWS Windows Server via HTTP
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Write-Host "üöÄ Starting deployment to AWS Windows Server via HTTP"

          # Validate required secrets
          if (-not "${{ secrets.AWS_HOST }}") { throw "‚ùå AWS_HOST secret is missing" }
          if (-not "${{ secrets.AWS_USER }}") { throw "‚ùå AWS_USER secret is missing" }
          if (-not "${{ secrets.AWS_PASSWORD }}") { throw "‚ùå AWS_PASSWORD secret is missing" }

          # Credentials
          $securePassword = ConvertTo-SecureString "${{ secrets.AWS_PASSWORD }}" -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential("${{ secrets.AWS_USER }}", $securePassword)

          # Session options to bypass certificate checks
          $sessionOptions = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck

          try {
            Write-Host "--- Phase 1: Testing WinRM Connection ---"
            Write-Host "üîó Testing connection to ${{ secrets.AWS_HOST }}:5985..."
            
            Test-WSMan -ComputerName "${{ secrets.AWS_HOST }}" -Port 5985 -Authentication Basic -Credential $credential -ErrorAction Stop
            Write-Host "‚úÖ WinRM connection successful"

            Write-Host "--- Phase 2: Establishing Remote Session ---"
            Write-Host "üì° Creating remote session..."
            
            $sessionParams = @{
                ComputerName = "${{ secrets.AWS_HOST }}"
                Credential = $credential
                Port = 5985
                Authentication = "Basic"
                SessionOption = $sessionOptions
                ErrorAction = "Stop"
            }
            
            $session = New-PSSession @sessionParams
            
            if (-not $session) {
                throw "Failed to create remote session"
            }
            Write-Host "‚úÖ Remote session established"

            Write-Host "--- Phase 3: Verifying Server Access ---"
            Write-Host "üîç Testing server access..."
            
            $serverInfo = Invoke-Command -Session $session -ScriptBlock {
                return @{
                    ComputerName = $env:COMPUTERNAME
                    OS = (Get-WmiObject Win32_OperatingSystem).Caption
                    Time = Get-Date
                    IISInstalled = (Get-WindowsFeature -Name Web-Server).Installed
                }
            }
            
            Write-Host "‚úÖ Server access verified:"
            Write-Host "   - Server: $($serverInfo.ComputerName)"
            Write-Host "   - OS: $($serverInfo.OS)"
            Write-Host "   - IIS Installed: $($serverInfo.IISInstalled)"

            Write-Host "--- Phase 4: Preparing Deployment Directory ---"
            Write-Host "üìÅ Setting up deployment directory..."
            
            Invoke-Command -Session $session -ScriptBlock {
                $deployPath = "C:\inetpub\wwwroot\myapp"
                $backupPath = "C:\inetpub\wwwroot\myapp_backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
                
                try {
                    # Create backup if directory exists
                    if (Test-Path $deployPath) {
                        Write-Host "üì¶ Backing up existing application..."
                        if (Test-Path $backupPath) {
                            Remove-Item $backupPath -Recurse -Force
                        }
                        Copy-Item $deployPath $backupPath -Recurse -Force
                        Write-Host "‚úÖ Backup created: $backupPath"
                    }
                    
                    # Ensure directory exists and is empty
                    if (-not (Test-Path $deployPath)) {
                        New-Item -Path $deployPath -ItemType Directory -Force | Out-Null
                    }
                    Remove-Item "$deployPath\*" -Recurse -Force -ErrorAction SilentlyContinue
                    Write-Host "‚úÖ Deployment directory ready: $deployPath"
                }
                catch {
                    Write-Error "Failed to prepare deployment directory: $($_.Exception.Message)"
                    throw
                }
            }

            Write-Host "--- Phase 5: Deploying Application Files ---"
            Write-Host "üì§ Copying files to server..."
            
            $files = Get-ChildItem -Path "./app" -Recurse | Measure-Object
            Write-Host "üìÑ Found $($files.Count) files to deploy"
            
            Copy-Item -Path "./app\*" -Destination "C:\inetpub\wwwroot\myapp\" -Recurse -Force -ToSession $session
            Write-Host "‚úÖ Files copied successfully"

            Write-Host "--- Phase 6: Finalizing Deployment ---"
            Write-Host "üîÅ Restarting IIS..."
            
            $iisResult = Invoke-Command -Session $session -ScriptBlock {
                try {
                    Write-Host "Stopping IIS..."
                    iisreset /stop
                    Start-Sleep -Seconds 2
                    Write-Host "Starting IIS..."
                    iisreset /start
                    Start-Sleep -Seconds 3
                    
                    # Verify IIS is running
                    $iisService = Get-Service -Name W3SVC -ErrorAction SilentlyContinue
                    if ($iisService -and $iisService.Status -eq 'Running') {
                        return @{ Success = $true; Message = "IIS restarted successfully" }
                    } else {
                        return @{ Success = $false; Message = "IIS service not running" }
                    }
                }
                catch {
                    return @{ Success = $false; Message = $_.Exception.Message }
                }
            }

            if (-not $iisResult.Success) {
                throw "IIS restart failed: $($iisResult.Message)"
            }
            Write-Host "‚úÖ $($iisResult.Message)"

            Write-Host "--- Phase 7: Cleanup ---"
            Remove-PSSession -Session $session
            Write-Host "‚úÖ Deployment completed successfully! üéâ"

          }
          catch {
            Write-Error "‚ùå DEPLOYMENT FAILED"
            Write-Error "Error: $($_.Exception.Message)"
            Write-Host "Stack Trace: $($_.Exception.StackTrace)"
            
            if ($session) {
                Remove-PSSession -Session $session -ErrorAction SilentlyContinue
                Write-Host "üßπ Cleaned up remote session"
            }
            
            exit 1
          }

      - name: Deployment Success Notification
        if: success()
        shell: pwsh
        run: |
          Write-Host "üéâ Deployment completed successfully!"
          Write-Host "üìÖ $(Get-Date)"
          Write-Host "üåê Application should be available at: http://${{ secrets.AWS_HOST }}/myapp"
